#!/usr/local/gauche/bin/speedygosh --timeout=3600
;#!/usr/local/gauche/bin/gosh

(define-module c-a-g.cgi
  (use www.cgi)
  (use rfc.http)
  (use text.html-lite)
  (use text.tree)
  (use srfi-1)
  (use srfi-13)
  (use rfc.uri)
  (use rfc.cookie)
  (use util.list)
  (use gauche.charconv)
  (export
    ))
(select-module c-a-g.cgi)

(define *cmd-proc-table*
  (make-hash-table 'equal?))
(define *cmd-desc-table* '())
(define-macro (define-cmd defines desc . bodies)
  (let ((cmd (car defines))
        (args (cdr defines)))
    `(begin
       (hash-table-put! *cmd-proc-table* ,(x->string cmd) (lambda ,args
                                                            ,@bodies))
       (set! *cmd-desc-table* (cons (cons ,(x->string cmd) ,desc)
                                    *cmd-desc-table*))
       )))

(define (main args)
  (set! (port-buffering (current-error-port)) :line)
  (cgi-main
    (lambda (params)
      (emit-content params))
    :on-error (lambda (e)
                (list
                  (cgi-header)
                  (html:pre
                    (html-escape-string
                      (call-with-output-string
                        (cut with-error-to-port <> (cut report-error e))))))))
  0)


(define (emit-content params)
  (let1 c (make-keyword (cgi-get-parameter "c" params :default ""))
    (case c
      ((:s) (emit-content-solve params))
      ((:h) (emit-content-help params))
      (else (emit-content-form params)))))


(define (emit-content-help params)
  (list
    (cgi-header :content-type "text/html; charset=utf-8"
                :pragma "no-cache"
                :cache-control "no-cache"
                )
    (html:html
      (html:head
        (html:title "C-A-G")
        )
      (html:body
        (html:div (html:a :href (self-url) "戻る"))
        (html:hr)
        (html:p
          "詳細については、"
          (html:a
            :href "https://github.com/ayamada/c-a-g"
            "リポジトリ")
          "を見て下さい。")
        (html:hr)
        (html:div "個別コマンド一覧")
        (html:dl
          (map
            (lambda (cmd+desc)
              (list
                (html:dt
                  (html:tt
                    (html-escape-string (car cmd+desc)) " (クエリ)"))
                (html:dd
                  (html-escape-string (cdr cmd+desc))
                  " にクエリ送信")))
            *cmd-desc-table*))))))


(define (emit-content-form params)
  (let ((query (cgi-get-parameter "q" params :default "")))
    (list
      (cgi-header :content-type "text/html; charset=utf-8"
                  :pragma "no-cache"
                  :cache-control "no-cache"
                  )
      (html:html
        (html:head
          (html:title "C-A-G")
          ;(html:script :src "/chaton/prototype.js" :type "text/javascript")
          )
        (html:body :id "the-body"
                   (the-form query)
                   )))))

(define (javascript . scripts)
  (html:script
    :type "text/javascript"
    (intersperse
      "\n"
      `("<!--"
        ,@scripts
        "// -->"))))

(define (the-form query)
  (html:form
    :action (self-url)
    :method "post"
    :target "_self"
    :name "send"
    (html:div
      (html:input :type "hidden" :name "c" :value "s")
      (html:textarea :name "q" :id "post-q"
                     :rows "3" :cols "40"
                     :onkeydown "if (event.keyCode == 13) { self.document.send.submit() }"
                     (html-escape-string query))
      (html:input :type "submit" ;:name "submit"
                  :id "post-submit" :value "解決")
      )
    (javascript "self.document.send.q.focus();")
    (html:div
      (html:a
        :href (append-params-to-url (self-url) '(("c" "h")))
        "説明"))))


(define (substring-byte src start end)
  (let1 result (make-byte-string (- end start))
    (for-each
      (lambda (idx)
        (string-byte-set!
          result
          (- idx start)
          (string-byte-ref src idx)))
      (iota (- end start) start))
    result))
(define (queries->lines:vimirc-single queries)
  (let1 r (map
            (lambda (line)
              (and-let* (
                         ;; マルチバイト文字のコンソール上の長さを正しく
                         ;; 判断する為に、一旦Shift_JISに変換する
                         (line-sjis (ces-convert line
                                                 (gauche-character-encoding)
                                                 'sjis))
                         ;; 末尾の | を検査する
                         (_ (< 67 (string-size line-sjis)))
                         (_ (= (char->integer #\|)
                               (string-byte-ref line-sjis 67)))
                         ;; 末尾の | 以降を切り落とす
                         (line2-sjis (substring-byte line-sjis 0 67))
                         ;; 先頭の | を検査する
                         (_ (= (char->integer #\|)
                               (string-byte-ref line2-sjis 20)))
                         ;; ログはじまりの空白を検査する
                         (_ (= (char->integer #\space)
                               (string-byte-ref line2-sjis 26)))
                         ;; ログはじまりの空白までを切り落とす
                         (line3-sjis (substring-byte line2-sjis 27 67))
                         )
                ;; Shift_JISから元に戻す
                (ces-convert line3-sjis 'sjis (gauche-character-encoding))))
            queries)
    (if (find-tail not r)
      #f ; 一個でも偽値があれば#fを返す
      r)))
(define (queries->lines:vimirc-multi queries)
  (let1 r (map
            (lambda (line)
              (and-let* (
                         ;; マルチバイト文字のコンソール上の長さを正しく
                         ;; 判断する為に、一旦Shift_JISに変換する
                         (line-sjis (ces-convert line
                                                 (gauche-character-encoding)
                                                 'sjis))
                         ;; 末尾の | を検査する
                         (_ (< 67 (string-size line-sjis)))
                         (_ (= (char->integer #\|)
                               (string-byte-ref line-sjis 67)))
                         ;; 末尾の | 以降を切り落とす
                         (line2-sjis (substring-byte line-sjis 0 67))
                         ;; 先頭の | を検査する
                         ;(_ (= (char->integer #\|)
                         ;      (string-byte-ref line2-sjis 20)))
                         ;; ログはじまりの空白を検査する
                         (_ (= (char->integer #\space)
                               (string-byte-ref line2-sjis 5)))
                         ;; ログはじまりの空白までを切り落とす
                         (line3-sjis (substring-byte line2-sjis 6 67))
                         )
                ;; Shift_JISから元に戻す
                (ces-convert line3-sjis 'sjis (gauche-character-encoding))))
            queries)
    (if (find-tail not r)
      #f ; 一個でも偽値があれば#fを返す
      r)))
(define (extract-url str)
  ;; strにurlが複数含まれていても、一つだけしか取り出さない
  ;; また、必要なら補完も行う事
  ;; TODO: あとで補完対応を行う事
  (and-let* ((m (*re:url* str)))
    (m)))

(define (dispatch-w-nl goto-url query)
  ;; 今のところ、vimircのコピペのみ対応
  ;; 対応する必要があるのは、以下のような、一行80文字までの、改行区切りの文字列
  ;; (例1:vimircのシングルモード)
  ;;  [1]irc.server-name.|01:48 <nick>: あいうえおかきくけこさしすせ htt|@nick2
  ;; *[3]#channel        |      p://www.google.com/ そたちつてとなにぬね|~
  ;; ~                   |      のはひふへほ                            |~
  ;; (例2:vimircのマルチモード)
  ;; 10:29 <nick03>: http://www.google.com/01234567890123456789012345678|nick04
  ;;       90123456789                                                  |~
  ;;
  ;; まず、行単位に分割(空行は除去)
  (let1 queries (filter
                  (lambda (x)
                    (not (string=? "" x)))
                  (string-split query  #/[\r\n]+/))
    ;; 全ての行が、上のシングルモードまたはマルチモードに完全一致
    ;; している事を確認し、発言部分のみを切り出し、そこからurlを抽出する
    (define (resolve-lines lines)
      (and-let* ((_ lines)
                 (str (apply string-append lines))
                 (url (extract-url str)))
        (goto-url url)))

    (cond
      ;; queriesが複数ない場合はパスする
      ((< (length queries) 2) #f)
      ;; singleを優先する必要がある(両方にマッチする可能性がある為)
      ((queries->lines:vimirc-single queries) => resolve-lines)
      ((queries->lines:vimirc-multi queries) => resolve-lines)
      (else #f))))

(define (dispatch-w-cmd goto-url cmd query)
  (and-let* ((proc (hash-table-get *cmd-proc-table* cmd #f))
             (result (proc query)))
    (goto-url result)))

(define *re:scheme*
  ;; http:// ttp:// tp://
  ;; (match 1) => https の "s" もしくは ""
  #/^(?:http|ttp|tp)(s?)\:\/\//)
(define *re:userpass*
  ;; 空、もしくは user@ もしくは user:pass@ 
  ;; TODO: 使用可能文字種増やすべきかも
  #/^(?:(?:[\w\%\-]+(?:\:[\w\%\-]+)?\@)|)/)
(define *re:domain*
  ;; domain.name:80
  ;; localhost等、dotを含まないものについてはdomainとはみなさない事にする
  #/^[\w\-]+(?:\.[\w\-]+)+(?:\:\d+)?/)
(define *re:rest*
  ;; 空、もしくは /... もしくは /...#...
  ;; fragment部にマルチバイト文字を許容するかどうかは微妙
  ;; TODO: ↓もう少しちゃんとする事
  #/^(?:|(?:\/[\!\#\$\%\&\'\(\)\*\+\,\-\.\/0-9\:\;\=\?\@A-Z\_a-z\~]+))$/)
(define *re:url*
  #/https?\:\/\/[\!\#\$\%\&\'\(\)\*\+\,\-\.\/0-9\:\;\=\?\@A-Z\_a-z\~]+/)

(define (dispatch-uri goto-url query)
  ;; uriとみなす為の判定に必要な部分は、以下の通り
  ;; - 文字列全体が*re:url*にマッチするなら、無条件でuri。
  ;;   しかし、そうでないなら、以下の判定を続行
  ;; - scheme部( http:// https:// ttp:// tp:// )。なくてもokだが要補完
  ;; - userpass部( user:pass@ )。なくてもok
  ;; - domain部( host.name )。必須
  ;; - rest部( /path/to/doc.html )。なくてもok
  ;; 尚、domain部以外は必須ではないが、完全にdomain部しか存在しない場合、
  ;; それはuriでない可能性が高い為、例外的にuriではない扱いとする
  (if (and-let* ((m (*re:url* query))
                 (_ (string=? "" (m 'before)))
                 (_ (string=? "" (m 'after))))
        #t)
    (goto-url query)
    (and-let* (
               ;; まず、whitespaceの除去を行う
               (query-wo-ws (regexp-replace-all #/\s/ query ""))
               ;; 各マッチを取得する(#fが出たら終了)
               (match-scheme (or
                               (*re:scheme* query-wo-ws) ; schemeあり
                               (#/^()/ query-wo-ws))) ; schemeなし
               (match-userpass (*re:userpass* (match-scheme 'after)))
               (match-domain (*re:domain* (match-userpass 'after)))
               (match-rest (*re:rest* (match-domain 'after)))
               (_ (not ; domain部しか存在しないなら、uri扱いしない
                    (and
                      (string=? "" (match-scheme))
                      (string=? "" (match-rest)))))
               (url (string-append
                      ;; scheme
                      (if (string=? "" (match-scheme))
                        "http://"
                        (string-append "http" (match-scheme 1) "://"))
                      ;; userpass
                      (match-userpass)
                      ;; domain
                      (match-domain)
                      ;; rest
                      (match-rest))))
      (goto-url url))))

(define (make-goto-url return)
  ;(define (goto-url url)
  ;  (return
  ;    (cgi-header
  ;      :pragma "no-cache"
  ;      :cache-control "no-cache"
  ;      :location url)))
  (define (goto-url url :optional (location #f))
    ;; http://www.teria.com/~koseki/memo/referrer/
    (return
      (if location
        (cgi-header
          :pragma "no-cache"
          :cache-control "no-cache"
          :location url)
        (list
          (cgi-header
            :pragma "no-cache"
            :cache-control "no-cache"
            :refresh #`"0; URL=,url")
          (html:html
            (html:head
              (html:meta :http-equiv "Refresh"
                         :content #`"0; URL=,url"))
            (html:body
              (html:div
                (html:a :href url (html-escape-string url)))))))))
  goto-url)

(define (emit-content-solve params)
  (let/cc return
    (let1 goto-url (make-goto-url return)
      ;; TODO: goto-urlを直に渡すのではなく、手続きの返り値がurlか#fかで
      ;;       分岐させるようにした方がいい
      (let* ((query (cgi-get-parameter "q" params :default ""))
             (_ (when (string=? "" query) (goto-url (self-url) #t)))
             ;; まず、改行が意味を持つ分岐を先に処理
             (_ (dispatch-w-nl goto-url query))
             ;; queryの先頭にコマンド指定がされているなら、先にそれを取り出す
             ;; コマンド文字列は、1〜4文字のasciiとする
             (cmd-match (#/^([\w\%\!\@\.\:\/\*\+\-]{1,4})(?:\s+|$)/ query))
             (cmd (and cmd-match (string-downcase (cmd-match 1))))
             (query-wo-cmd (if cmd-match (cmd-match 'after) query))
             ;; 改行を除去する
             (query-wo-nl (regexp-replace-all #/\n|\r/ query-wo-cmd " "))
             ;; 末尾のwhitespaceを除去
             (query-wo-nl/trimmed (regexp-replace #/\s+$/ query-wo-nl ""))
             (_ (when (and
                        (not cmd)
                        (string=? "" query-wo-nl/trimmed))
                  (goto-url (self-url) #t)))
             ;; コマンドを処理
             (_ (dispatch-w-cmd goto-url cmd query-wo-nl/trimmed))
             ;; コマンドではなかったので、コマンド部を再結合
             (cmd+query-wo-nl/trimmed (cond
                                        ((not cmd) query-wo-nl/trimmed)
                                        ((equal? "" query-wo-nl/trimmed) cmd)
                                        (else
                                          (string-append
                                            cmd
                                            " "
                                            query-wo-nl/trimmed))))
             ;; 内容がuriっぽかったら、uriとして処理を行う
             (_ (dispatch-uri goto-url cmd+query-wo-nl/trimmed))
             )
        ;; どれにもマッチしなかった。google検索する
        (goto-url
          (append-params-to-url
            "http://www.google.com/search"
            `(("q" ,cmd+query-wo-nl/trimmed))))))))


(define (append-params-to-url url params)
  (if (null? params)
    url
    (receive (url-without-fragment fragment) (let1 m (#/(\#.*)/ url)
                                               (if m
                                                 (values (m 'before) (m 1))
                                                 (values url "")))
      (call-with-output-string
        (lambda (p)
          (letrec ((delimitee (if (#/\?/ url-without-fragment)
                                (lambda () "&")
                                (lambda ()
                                  (set! delimitee (lambda () "&"))
                                  "?"))))
            (display url-without-fragment p)
            (let loop ((left-params params))
              (if (null? left-params)
                (display fragment p)
                (let ((key-encoded (uri-encode-string (caar left-params)))
                      (vals (cdar left-params))
                      (next-left (cdr left-params))
                      )
                  (if (pair? vals)
                    (for-each
                      (lambda (val)
                        (display (delimitee) p) ; "?" or "&"
                        (display key-encoded p)
                        (display "=" p)
                        (display (uri-encode-string (if (string? val) val "")) p))
                      vals)
                    (begin
                      (display (delimitee) p)
                      (display key-encoded p)))
                  (loop next-left))))))))))

(define (completion-uri uri server-name server-port https)
  (receive (uri-scheme
            uri-userinfo
            uri-hostname
            uri-port
            uri-path
            uri-query
            uri-fragment) (uri-parse uri)
    ;; uri-schemeが無い時にだけ補完する
    ;; 但し、server-nameが与えられていない場合は補完できないので、何もしない
    (if (or uri-scheme (not server-name))
      uri
      (let* ((scheme (if https "https" "http"))
             (default-port (if https 443 80))
             )
        (uri-compose
          :scheme scheme
          :userinfo uri-userinfo
          :host server-name
          :port (and
                  server-port
                  (not (eqv? default-port (x->number server-port)))
                  server-port)
          :path uri-path
          :query uri-query
          :fragment uri-fragment)))))

(define (path->url path)
  (if (#/^\// path)
    (completion-uri
      path
      (cgi-get-metavariable "SERVER_NAME")
      (cgi-get-metavariable "SERVER_PORT")
      (cgi-get-metavariable "HTTPS"))
    path))

(define (self-url)
  (path->url (self-path)))

(define (self-url/path-info)
  (path->url (self-path/path-info)))

(define (self-url/slash)
  (string-append (self-url) "/"))

(define (self-path)
  (or (cgi-get-metavariable "SCRIPT_NAME") "/"))

(define (self-path/path-info)
  ;; note: PATH_INFOは既にデコードされてしまっているので使わない事
  (let* ((r (or (cgi-get-metavariable "REQUEST_URI") "/"))
         (m (#/\?/ r))
         )
    (if m
      (m 'before)
      r)))

(define (self-path/slash)
  (string-append (self-path) "/"))






;;; 以下は、個々のコマンド定義

(define-cmd (h query)
  "HEAD"
  ;; TODO: あとでHEADする機能を追加する事
  ;; TODO: 外部に別cgiを作らず、リダイレクト無しにHEADするには、
  ;;       もう少し拡張する必要がある
  (string-append
    (self-url)
    "?q=not%20implemented"))
(define-cmd (e query)
  "英辞郎"
  (string-append
    "http://eow.alc.co.jp/"
    (uri-encode-string query)
    "/UTF-8/"))
(define-cmd (w query)
  "ja.wikipedia.org"
  (string-append
    "http://ja.wikipedia.org/wiki/"
    (uri-encode-string query)))
(define-cmd (a query)
  "amazon.co.jp"
  (string-append
    "http://www.amazon.co.jp/s/?__mk_ja_JP="
    (uri-encode-string "カタカナ")
    "&url=search-alias%3Daps&field-keywords="
    (uri-encode-string query)))
(define-cmd (j query)
  "jwhois.cgi"
  (string-append
    "http://sakura.tir.jp/jwhois.cgi?q="
    (uri-encode-string query)))
;(define-cmd (ej query)
;  "英和"
;  ...)
;(define-cmd (je query)
;  "和英"
;  ...)
(define-cmd (g query)
  "gauche-refj"
  (string-append
    ;; TODO: 先にpractical-schemeで探して、なかったらcallccで探すようにしたい
    ;;       どうやって実現する？
    ;;       一番簡単なのは、practical-schemeをhttp-getしてみて、
    ;;       そのlocation先が
    ;;       http://practical-scheme.net/gauche/man/gauche-refj.html
    ;;       かどうかを見る、という方法だが
    ;"http://www.callcc.net/gauche/refj/estseek.cgi?order=%40size+NUMA&phrase="
    "http://practical-scheme.net/gauche/man/?l=jp&p="
    (uri-encode-string query)))






;;;===================================================================

(select-module user)
(define main (with-module c-a-g.cgi main))

;; Local variables:
;; mode: scheme
;; end:
;; vim: set ft=scheme:
